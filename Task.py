"""
Задание №1. На языке Python реализовать алгоритм (функцию) определения четности целого числа, который будет аналогичен
нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций.

- Вариант №1 быстрее, чем Вариант №2, т.к. мы рекурсивно несколько раз вызываем функцию, которая просто отнимает 2 и в конце
   определяем остаток. Операция деления в первом варианте будет быстрее выполняться.

- Вариант №2 будет работать быстрее, чем Вариант №1, т.к. Вариант №2 выполняет низкоуровневую операцию
"""


# Вариант№1
def isEven1(value):
    return value % 2 == 0


# Вариант№2
def isEven2(value):
    value = abs(value)
    if value == 0:
        return True
    elif value == 1:
        return False
    return isEven1(value - 2)


# Вариант№3
def isEven3(value):
    return value & 1 == 0


"""
Задание №2. Реализовать минимум по 2 класса реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.


"""


# Вариант №1
class CircularBuffer():
    def __init__(self, size=10):
        self._size = size  # Размер буфера
        self._count_elements = 0  # Количесвто элементов в буфере
        self._buffer = [0] * size  # Создаем пустой буфер
        self._begin = 0  # Указатель на начало буфера

    def full_buffer(self):  # Метод проверяющий буфер заполнен или нет
        return self._size == self._count_elements

    def enqueue(self, element):  # Метод добавления в буфер элемента
        if self.full_buffer():  # Если буфер заполнен вызываем исключение
            raise Exception("Буфер заполнен")
        index = (self._begin + self._count_elements) % self._size  # Находим индекс по которому добавиться новый элемент
        self._buffer[index] = element  # Добавляем элемент в буфер
        self._count_elements += 1  # Увеличиваем количество элементов буфера

    def dequeue(self):  # Метод получения элемента из очереди
        if self._count_elements == 0:  # Если буфер пустой вызываем исключение
            raise Exception("Буфер пустой")

        item = self._buffer[self._begin]  # Записываем элемент в переменную
        self._count_elements -= 1  # Уменьшаем количесвто элементов в буфере
        self._begin += 1  # Передвигаем указатель начало буфера

        if self._begin >= self._size: # Проверяем, если указатель на начало выходит за границы размера буфера, то назначем ему 0
            self._begin = 0

        return item  # Выводим полученный элемент

    def clear(self):
        self._count_elements = 0  # Очищаем количество элементов в буфере, чем и ощичаем сам буфер


"""
Задание №3. На языке Python реализовать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей 
массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить 
почему вы считаете, что функция соответствует заданным критериям.

Сортировка слиянием быстрее справится с поставленной задачей, т.к. худшее время выполнение алгоритма O(n log n), а например
у быстрой сортировки худшее время O(n^2)
"""
def Merge_Sort(arr):
    if len(arr) == 1:  # Проверяем, если длина массива равна 1, то считаем массив отсортированным
        return arr
    middle = len(arr) // 2  # Полученный массив делим примерно на равные половины
    left = arr[:middle]  # записываем половины условно на левую и правую
    right = arr[middle:]

    Merge_Sort(left)  # Рекурсивно производим операции с полученными половинами
    Merge_Sort(right)

    i = j = k = 0

    while i < len(left) and j < len(right):  # пока переменые i и j не равны длиннам массивов продолжаем цикл
        if left[i] < right[j]:  # Сравниваем элементы с правой и левой части, если левая меньше, то записываем ее в массив
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]  # Иначе записываем правый элемент
            j += 1
        k += 1

    while i < len(left):
        arr[k] = left[i]
        i += 1
        k += 1

    while j < len(right):
        arr[k] = right[j]
        j += 1
        k += 1